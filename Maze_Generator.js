//started 10/28/20
//inspiration: https://www.youtube.com/watch?v=HyK_Q5rrcr4, https://www.youtube.com/watch?v=D8UgRyRnvXU, https://www.youtube.com/watch?v=8Ju_uxJ9v44, https://www.youtube.com/watch?v=_p5IH0L63wo
//generates a random maze, starts with a random walk until a specified amount of time has passed, at which point it switches ot deptch-first backtracking, therefore longer generation time will lead to harder mazes

const squareSize = 20;
const showProgress = true; //for turning off display while creating the maze
const difficulty = 0.5; //literally the (zero to one) percentage of cells generated by random walk


let numRows, numColumns;
const maze = []; //will be a 2D array
let currentCell;
const visitedCellsStack = [];
let doneGenerating = false;
const mazeGraphic = new MazeGraphic();
let randomWalk = true;


function setup() {
  createCanvas(400, 400);
  background(0);
  stroke(255);
  noFill();
  if (squareSize == 0 || squareSize > width || squareSize > height) {
    console.log("Error: square size is too small.");
    print("Error: square size is too small.");
    doneGenerating = true;
    noLoop();
    return;
  }

  numRows = floor(height / squareSize);
  numColumns = floor(width / squareSize);
  for (let row = 0; row < numRows; ++row) {
    maze[row] = [];
    for (let column = 0; column < numColumns; ++column) {
      maze[row].push(new Cell(column, row));
    }
  }

  currentCell = maze[int(random(numRows))][int(random(numColumns))];
  currentCell.isVisited = true;
  visitedCellsStack.push(new Point(currentCell.x, currentCell.y)); //FIXME: the whole cell, or just the needed parts (namely the x and y)?
  if (visitedCellsStack.length == numRows * numColumns) {
    doneGenerating = true;
    MazeGraphic();
  }
}


function draw() {
  if (!doneGenerating) {
    if (showProgress) {
      rect(0, 0, numColumns * squareSize, numRows * squareSize);
      for (let row = 0; row < numRows; ++row) {
        for (let column = 0; column < numColumns; ++column) {
          maze[row][column].show();
        }
      }
      console.log(frameRate().toFixed(1) + " FPS"); // //just for kicks
      console.log(millis().toFixed(0) / 1000 + "s"); // //just for kicks
      console.log(visitedCellsStack.length + " cells"); // //just for kicks
      console.log("randomly walking: " + randomWalk); // //just for kicks
    }

    if (!randomWalk) { //depth-first with backtracking maze generation (easy-maze generation)
      const nextCell = currentCell.getRandomNeighbor(false);
      if (nextCell == undefined) {
        if (visitedCellsStack.length != 0) {
          const p = visitedCellsStack.pop();
          currentCell = maze[p.y][p.x];
        } else {
          doneGenerating = true;
          mazeGraphic.generate();
        }
      } else {
        if (!nextCell.isVisited) {
          if (currentCell.y - nextCell.y == 1) { //moving up
            currentCell.isWall[0] = false;
          } else if (currentCell.y - nextCell.y == -1) { //moving down
            nextCell.isWall[0] = false;
          } else if (currentCell.x - nextCell.x == 1) { //moving left
            currentCell.isWall[1] = false;
          } else if (currentCell.x - nextCell.x == -1) { //moving right
            nextCell.isWall[1] = false;
          }
        }
        visitedCellsStack.push(new Point(nextCell.x, nextCell.y)); //FIXME: the whole cell, or just the needed parts (namely the x and y)?
        if (visitedCellsStack.length == numRows * numColumns) {
          doneGenerating = true;
          mazeGraphic.generate();
        }
        currentCell = nextCell;
      }
    } else { //random-walk maze generation (hard-maze generation)
      const nextCell = currentCell.getRandomNeighbor(undefined);
      if (!nextCell.isVisited) {
        if (currentCell.y - nextCell.y == 1) { //moving up
          currentCell.isWall[0] = false;
        } else if (currentCell.y - nextCell.y == -1) { //moving down
          nextCell.isWall[0] = false;
        } else if (currentCell.x - nextCell.x == 1) { //moving left
          currentCell.isWall[1] = false;
        } else if (currentCell.x - nextCell.x == -1) { //moving right
          nextCell.isWall[1] = false;
        }
        visitedCellsStack.push(new Point(nextCell.x, nextCell.y)); //FIXME: the whole cell, or just the needed parts (namely the x and y)?
        if (visitedCellsStack.length >= int(difficulty * numRows * numColumns)) {
          randomWalk = false;
        }
        if (visitedCellsStack.length == numRows * numColumns) {
          doneGenerating = true;
          mazeGraphic.generate();
        }
      }
      currentCell = nextCell;
    }
    currentCell.isVisited = true;
  } else {
    background(0);
    mazeGraphic.show();
    console.log(frameRate().toFixed(1) + " FPS"); //just for kicks
    console.log(millis().toFixed(0) / 1000 + "s"); //just for kicks
  }
}


function Cell(x, y) {
  this.x = x;
  this.y = y;
  this.xpos = x * squareSize;
  this.ypos = y * squareSize;
  this.isWall = [true, true]; //cells only keep track of their top and left walls (respectively)
  this.isVisited = false;

  this.getRandomNeighbor = function(hasBeenVisited) {
    const neighbors = [];
    if (hasBeenVisited == undefined) { //get a random neighbor without care for whether they have been visited
      if (this.y != 0) { //top
        neighbors.push(maze[this.y - 1][this.x]);
      }
      if (this.y != numRows - 1) { //bottom
        neighbors.push(maze[this.y + 1][this.x]);
      }
      if (this.x != 0) { //left
        neighbors.push(maze[this.y][this.x - 1]);
      }
      if (this.x != numColumns - 1) { //right
        neighbors.push(maze[this.y][this.x + 1]);
      }
    } else if (hasBeenVisited) { //get a random neighbor that has been visited, returning undefined if one does not exist
      if (this.y != 0 && maze[this.y - 1][this.x].isVisited) { //top
        neighbors.push(maze[this.y - 1][this.x]);
      }
      if (this.y != numRows - 1 && maze[this.y + 1][this.x].isVisited) { //bottom
        neighbors.push(maze[this.y + 1][this.x]);
      }
      if (this.x != 0 && maze[this.y][this.x - 1].isVisited) { //left
        neighbors.push(maze[this.y][this.x - 1]);
      }
      if (this.x != numColumns - 1 && maze[this.y][this.x + 1].isVisited) { //right
        neighbors.push(maze[this.y][this.x + 1]);
      }
    } else { //get a random neighbor that has not been visited, returning undefined if one does not exist
      if (this.y != 0 && !maze[this.y - 1][this.x].isVisited) { //top
        neighbors.push(maze[this.y - 1][this.x]);
      }
      if (this.y != numRows - 1 && !maze[this.y + 1][this.x].isVisited) { //bottom
        neighbors.push(maze[this.y + 1][this.x]);
      }
      if (this.x != 0 && !maze[this.y][this.x - 1].isVisited) { //left
        neighbors.push(maze[this.y][this.x - 1]);
      }
      if (this.x != numColumns - 1 && !maze[this.y][this.x + 1].isVisited) { //right
        neighbors.push(maze[this.y][this.x + 1]);
      }
    }
    return neighbors[int(random(neighbors.length))];
  }

  this.show = function() {
    if (this.isWall[0]) {
      line(this.xpos, this.ypos, this.xpos + squareSize, this.ypos); //top
    }
    if (this.isWall[1]) {
      line(this.xpos, this.ypos, this.xpos, this.ypos + squareSize); //left
    }
    if (showProgress && this.isVisited) {
      noStroke();
      fill(63);
      rect(this.xpos, this.ypos, squareSize, squareSize);
      stroke(255);
      noFill();
    }
  }

}


function MazeGraphic() { //note: this representation is not actually proven to be faster, but is only assumed to be
  this.wallSegments = [];

  this.show = function() {
    for (let i = 0; i < this.wallSegments.length; ++i) {
      line(this.wallSegments[i].x, this.wallSegments[i].y, this.wallSegments[i].horizontalLength, this.wallSegments[i].verticalLength);
    }
  }

  this.generate = function() {
    this.wallSegments.push(new LineSegment(0, 0, numColumns * squareSize, 0)); //top border
    this.wallSegments.push(new LineSegment(0, 0, 0, numRows * squareSize)); //left border
    this.wallSegments.push(new LineSegment(0, numRows * squareSize, numColumns * squareSize, numRows * squareSize)); //bottom border
    this.wallSegments.push(new LineSegment(numColumns * squareSize, 0, numColumns * squareSize, numRows * squareSize)); //right border
    for (let column = 1; column < numColumns; ++column) { //vertical lines
      let lineStart = undefined;
      let lineEnd = undefined;
      for (let row = 0; row < numRows; ++row) {
        if (maze[row][column].isWall[1]) {
          if (lineStart == undefined) {
            lineStart = row;
            lineEnd = lineStart + 1;
          } else {
            lineEnd = row + 1;
          }
        } else {
          if (lineStart != undefined) {
            this.wallSegments.push(new LineSegment(column * squareSize, lineStart * squareSize, column * squareSize, lineEnd * squareSize));
            lineStart = undefined;
            lineEnd = undefined;
          }
        }
      }
      if (lineStart != undefined) {
        this.wallSegments.push(new LineSegment(column * squareSize, lineStart * squareSize, column * squareSize, lineEnd * squareSize));
        lineStart = undefined;
        lineEnd = undefined;
      }
    }

    for (let row = 1; row < numRows; ++row) { //horizontal lines
      let lineStart = undefined;
      let lineEnd = undefined;
      for (let column = 0; column < numColumns; ++column) {
        if (maze[row][column].isWall[0]) {
          if (lineStart == undefined) {
            lineStart = column;
            lineEnd = lineStart + 1;
          } else {
            lineEnd = column + 1;
          }
        } else {
          if (lineStart != undefined) {
            this.wallSegments.push(new LineSegment(lineStart * squareSize, row * squareSize, lineEnd * squareSize, row * squareSize));
            lineStart = undefined;
            lineEnd = undefined;
          }
        }
      }
      if (lineStart != undefined) {
        this.wallSegments.push(new LineSegment(lineStart * squareSize, row * squareSize, lineEnd * squareSize, row * squareSize));
        lineStart = undefined;
        lineEnd = undefined;
      }
    }
  }
}


function LineSegment(x, y, hl, vl) {
  this.x = x;
  this.y = y;
  this.horizontalLength = hl;
  this.verticalLength = vl;
}


function Point(x, y) { //used to reduce the memory usage of the visited cells stack by only pushing the respective coordinates
  this.x = x;
  this.y = y;
}