/* globals Cell, MazeGraphic, Point */
/* exported maze, numColumns, numRows, showProgress, squareSize */
const squareSize = 20;
const showProgress = true; //for turning off display while creating the maze
const difficulty = 0.5; //literally the (zero to one) percentage of cells generated by random walk


let numRows, numColumns;
const maze = []; //will be a 2D array
let currentCell;
const visitedCellsStack = [];
let doneGenerating = false;
const mazeGraphic = new MazeGraphic();
let randomWalk = true;


function setup() {
  createCanvas(400, 400);
  background(0);
  stroke(255);
  noFill();
  if (squareSize == 0 || squareSize > width || squareSize > height) {
    console.log("Error: square size is too small.");
    print("Error: square size is too small.");
    doneGenerating = true;
    noLoop();
    return;
  }

  numRows = floor(height / squareSize);
  numColumns = floor(width / squareSize);
  for (let row = 0; row < numRows; ++row) {
    maze[row] = [];
    for (let column = 0; column < numColumns; ++column) {
      maze[row].push(new Cell(column, row));
    }
  }

  currentCell = maze[int(random(numRows))][int(random(numColumns))];
  currentCell.isVisited = true;
  visitedCellsStack.push(new Point(currentCell.x, currentCell.y));
  if (visitedCellsStack.length == numRows * numColumns) {
    doneGenerating = true;
    MazeGraphic();
  }
}


function draw() {
  if (!doneGenerating) {
    if (showProgress) {
      rect(0, 0, numColumns * squareSize, numRows * squareSize);
      for (let row = 0; row < numRows; ++row) {
        for (let column = 0; column < numColumns; ++column) {
          maze[row][column].show();
        }
      }
      console.log(frameRate().toFixed(1) + " FPS");
      console.log(millis().toFixed(0) / 1000 + "s");
      console.log(visitedCellsStack.length + " cells");
      console.log("randomly walking: " + randomWalk);
    }

    if (!randomWalk) { //depth-first with backtracking maze generation (easy-maze generation)
      const nextCell = currentCell.getRandomNeighbor(false);
      if (nextCell == undefined) {
        if (visitedCellsStack.length != 0) {
          const p = visitedCellsStack.pop();
          currentCell = maze[p.y][p.x];
        } else {
          doneGenerating = true;
          mazeGraphic.generate();
        }
      } else {
        if (!nextCell.isVisited) {
          if (currentCell.y - nextCell.y == 1) { //moving up
            currentCell.isWall[0] = false;
          } else if (currentCell.y - nextCell.y == -1) { //moving down
            nextCell.isWall[0] = false;
          } else if (currentCell.x - nextCell.x == 1) { //moving left
            currentCell.isWall[1] = false;
          } else if (currentCell.x - nextCell.x == -1) { //moving right
            nextCell.isWall[1] = false;
          }
        }
        visitedCellsStack.push(new Point(nextCell.x, nextCell.y));
        if (visitedCellsStack.length == numRows * numColumns) {
          doneGenerating = true;
          mazeGraphic.generate();
        }
        currentCell = nextCell;
      }
    } else { //random-walk maze generation (hard-maze generation)
      const nextCell = currentCell.getRandomNeighbor(undefined);
      if (!nextCell.isVisited) {
        if (currentCell.y - nextCell.y == 1) { //moving up
          currentCell.isWall[0] = false;
        } else if (currentCell.y - nextCell.y == -1) { //moving down
          nextCell.isWall[0] = false;
        } else if (currentCell.x - nextCell.x == 1) { //moving left
          currentCell.isWall[1] = false;
        } else if (currentCell.x - nextCell.x == -1) { //moving right
          nextCell.isWall[1] = false;
        }
        visitedCellsStack.push(new Point(nextCell.x, nextCell.y));
        if (visitedCellsStack.length >= int(difficulty * numRows * numColumns)) {
          randomWalk = false;
        }
        if (visitedCellsStack.length == numRows * numColumns) {
          doneGenerating = true;
          mazeGraphic.generate();
        }
      }
      currentCell = nextCell;
    }
    currentCell.isVisited = true;
  } else {
    background(0);
    mazeGraphic.show();
    console.log(frameRate().toFixed(1) + " FPS"); //just for kicks
    console.log(millis().toFixed(0) / 1000 + "s"); //just for kicks
  }
}